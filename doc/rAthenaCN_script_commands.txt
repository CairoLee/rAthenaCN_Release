//===== rAthenaCN 文档 =======================================
//= rAthenaCN 脚本指令说明文件
//===== 作者: ================================================
//= rAthenaCN 开发团队
//===== 最后更新: ============================================
//= 20161005
//===== 文档简介: ============================================
//= rAthenaCN 是基于 rAthena 进行二次开发的, 在 rAthena 官方支
//= 持的脚本指令基础上, rAthenaCN 也拓展了一些脚本指令, 请参阅
//= 下面的说明, 它会重点介绍脚本指令的参数和用法.
//============================================================

脚本指令别名表
--------------

为了兼容一些其他服务端的脚本, 部分脚本指令拥有别名, 使用别名和使用原名的语法和效果是一样的.

┌──────────────────────────────┬─────────────────────────────┐
│ 指令原名 (推荐使用)          │ 指令的别名                  │
├──────────────────────────────┼─────────────────────────────┤
│ *itemexists                  │ *existitem                  │
├──────────────────────────────┼─────────────────────────────┤
│ *setrenttime                 │ *resume                     │
├──────────────────────────────┼─────────────────────────────┤
│ *getequipexpiretick          │ *isrental                   │
├──────────────────────────────┼─────────────────────────────┤
│ *gethotkey                   │ *get_hotkey                 │
├──────────────────────────────┼─────────────────────────────┤
│ *sethotkey                   │ *set_hotkey                 │
├──────────────────────────────┼─────────────────────────────┤
│ *recalculatestat             │ *statuscalc 或 *status_calc │
├──────────────────────────────┼─────────────────────────────┤
│ *copynpc                     │ *dupnpc                     │
└──────────────────────────────┴─────────────────────────────┘


脚本指令说明
------------

*warpparty2 "<目标地图名称>",<x>,<y>,<队伍编号>,{"<来自的地图名称>"};

用法和 warpparty 一样, 都是将指定队伍的全部队员统一传送到指定的目的地. 如果指定了最后一个参数, 那么只有位于“来自的地图名称”的队员会被传送.

两者之间的区别在于: 
	warpparty 对已经死亡的队友则无效(死亡的队友会被留在原地), 而 warpparty2 对已经死亡的队友有效(会被立刻以 1HP 的血量复活, 并一起被传送走).

---------------------------------------

*setheaddir <朝向编号>{,<角色编号>};

用于调整角色的脑袋朝向.

朝向编号:
	0为看正前方, 1为向右看, 2为向左看
	
返回值:
	该指令无论成功失败, 都不会有返回值

---------------------------------------

*setbodydir <朝向编号>{,<角色编号>};

用于调整角色身体的朝向.

朝向编号:
	和NPC的朝向编号一样, 从 0 到 7 一共8个方位可选择.
	
返回值:
	该指令无论成功失败, 都不会有返回值

---------------------------------------

*party_leave {<角色编号>};

用于让指定的角色立刻退出队伍.

返回值:
	若指定角色不在线或不在队伍中, 则返回 0, 成功则返回 1

---------------------------------------

*openbank {<角色编号>};

用于让指定的角色立刻打开银行界面(只对拥有账号随身银行的客户端版本有效).

返回值:
	若指定角色不在线, 则返回 0, 成功则返回 1

---------------------------------------

*instance_users <副本的实例编号>;

用于获取指定的副本实例中的参与人数.

返回值:
	成功直接返回副本中的人数, 副本不存在或副本中无人存在则返回 0

---------------------------------------

*mesclear;

清空当前NPC的对话框内容, 借此你可以在无需玩家点击"Next"按钮的情况下, 使用 mes 指令来刷新对话窗口的内容.

返回值:
	该指令无论成功失败, 都不会有返回值

---------------------------------------

*cap_value <数值>,<最小值>,<最大值>;

用来确保数值变量不会低于最小值, 超过最大值. 

返回值:
	如果低于最小值则直接返回最小值, 如果超过最大值则直接返回最大值, 如果在两者之间则原样返回数值.

---------------------------------------

*mobremove <魔物的GID>;

根据GID移除一个魔物(只是移除, 不会让魔物死亡), 合适用来编写副本剧情.

返回值:
	该指令无论成功失败, 都不会有返回值

---------------------------------------

*getsameipinfo {<"IP地址">};

获得某个IP在线的玩家数以及玩家的角色编号等信息, 若不携带<"IP地址">参数, 则该参数默认为当前脚本关联角色的IP地址.

如果执行成功的话, 会赋予以下数组在线玩家的信息:

@sameip_aid[]		使用指定IP在线的玩家账号编号数组(AccountID)
@sameip_cid[]		使用指定IP在线的玩家角色编号数组(CharID)
@sameip_name$[]		使用指定IP在线的玩家角色名数组

返回值及 @sameip_amount 变量都会赋予目前使用指定IP登录的玩家个数.

返回值:
	0 表示出错或此IP地址目前没有任何玩家在线; 如果大于 0 那么代表目前使用此 IP 在线的玩家数.

---------------------------------------

*logout <登出理由编号>{,"<角色名称>"|<账号编号>|<角色编号>};

使指定的角色立刻登出游戏(踢下线), 这里的"登出理由编号"只能做参考, 不同的理由编号会让客户端给玩家显示不同的提示文本(下面的信息会在以后汉化):

	0 = BAN_UNFAIR
	1 = server closed -> MsgStringTable[4]
	2 = ID already logged in -> MsgStringTable[5]
	3 = timeout/too much lag -> MsgStringTable[241]
	4 = server full -> MsgStringTable[264]
	5 = underaged -> MsgStringTable[305]
	8 = Server sill recognizes last connection -> MsgStringTable[441]
	9 = too many connections from this ip -> MsgStringTable[529]
	10 = out of available time paid for -> MsgStringTable[530]
	11 = BAN_PAY_SUSPEND
	12 = BAN_PAY_CHANGE
	13 = BAN_PAY_WRONGIP
	14 = BAN_PAY_PNGAMEROOM
	15 = disconnected by a GM -> if( servicetype == taiwan ) MsgStringTable[579]
	16 = BAN_JAPAN_REFUSE1
	17 = BAN_JAPAN_REFUSE2
	18 = BAN_INFORMATION_REMAINED_ANOTHER_ACCOUNT
	100 = BAN_PC_IP_UNFAIR
	101 = BAN_PC_IP_COUNT_ALL
	102 = BAN_PC_IP_COUNT
	103 = BAN_GRAVITY_MEM_AGREE
	104 = BAN_GAME_MEM_AGREE
	105 = BAN_HAN_VALID
	106 = BAN_PC_IP_LIMIT_ACCESS
	107 = BAN_OVER_CHARACTER_LIST
	108 = BAN_IP_BLOCK
	109 = BAN_INVALID_PWD_CNT
	110 = BAN_NOT_ALLOWED_JOBCLASS
	? = disconnected -> MsgStringTable[3]

返回值:
	该指令无论成功失败, 都不会有返回值

---------------------------------------

*searcharray <数组变量>,<要查询的内容>;

查询数组中第一次出现待查询内容的索引序号, 使用它来搜索数组内容很方便(用法比较丰富, 以后再举例细说).

返回值:
	若查不到结果则返回 -1, 否则返回大于等于 0 的序号

---------------------------------------

*getinventorylist {<角色编号>};

在原来返回的数组基础上, rAthenaCN 新增了以下返回数组:

- @inventorylist_idx[] 用来返回每个道具的背包位置序号.
- @inventorylist_uid$[] 用来返回每个道具的装备唯一编号(字符串类型数组).

注意:
	背包位置序号每一次登录、每一次玩家在自己的背包中增删物品(包括但不限: 
	存仓、存手推车、丢弃、购买和使用道具等操作)都可能会导致背包位置序号有变化. 
	所以请注意在一段连续、玩家不可能会停下来做其他动作的脚本中去使用“背包位置序号”. 
	否则, 只要你在 getinventorylist 之后, 还给玩家空隙去进行道具的增删, 
	那么 @inventorylist_idx[] 中的数据将不再可靠.

---------------------------------------

*delinventory <背包位置序号>,<要移除的数量>;

移除指定背包序号指定数量的道具. 

这里的背包位置序号可以通过 getinventorylist 脚本指令的 @inventorylist_idx[] 数组来获得.

返回值:
	操作成功则返回 1, 失败或没那么多道具可以删则返回 0

---------------------------------------

*countinventory <背包位置序号>;

根据指定背包序号, 获取该道具在背包中的数量.

返回值:
	直接返回物品的数量, 若改背包序号的物品不存在则返回 0

---------------------------------------

*identifybyidx <背包位置序号>;

根据指定的背包序号, 对该道具进行鉴定操作.

返回值:
	该指令无论成功失败, 都不会有返回值

---------------------------------------

*equipinventory <背包位置序号>;

穿戴指定背包位置的装备.

这里的背包位置序号可以通过 getinventorylist 脚本指令的 @inventorylist_idx[] 数组来获得.

返回值:
	操作操作成功则返回 1, 失败则返回 0

---------------------------------------

*unequipinventory <背包位置序号>;

脱下指定背包位置的装备.

这里的背包位置序号可以通过 getinventorylist 脚本指令的 @inventorylist_idx[] 数组来获得.

返回值:
	操作操作成功则返回 1, 失败则返回 0

---------------------------------------

*getinventoryinfo <背包位置序号>,<要查看的信息类型>;

查看指定背包位置的道具信息.

这里的背包位置序号可以通过 getinventorylist 脚本指令的 @inventorylist_idx[] 数组来获得.

要查看的信息类型:
	0 	- 物品编号
	1 	- 堆叠数量
	2 	- 装备的穿戴位置(如果为 0 则表示还没穿戴在身上, 位置请参考 EQP_* 开头的常量)
	3 	- 精炼值
	4 	- 是否已经鉴定(1为已鉴定, 0为未鉴定)
	5 	- 属性(说是属性, 其实最常用是用来判断物品是否损坏, 若损坏则返回1, 没坏则返回 0)
	6 	- 第一个卡槽的卡片编号
	7 	- 第二个卡槽的卡片编号
	8 	- 第三个卡槽的卡片编号
	9 	- 第四个卡槽的卡片编号
	10	- 过期时间(Unix时间戳, 0 表示永不过期)
	11	- 装备的唯一编号(unique_id) - 注意: 返回字符串类型的变量

注意:
	若你想获取装备的唯一编号, 那么用来存放返回值的必须是一个字符串类型的变量(变量结尾带$符号),
	如果用来存放返回值的变量是数值类型的话, 那么拿到的值不是装备的唯一编号.
	
	.@uid$ = getinventoryinfo(背包序号, 11);	// 正确
	.@uid = getinventoryinfo(背包序号, 11);		// 错误
	
返回值:
	失败则返回 -1, 成功则返回你所查询的信息的值
	
---------------------------------------

*viewequip <对方的账号编号>{,<是否强制查看>};

查看指定账号在线角色的装备信息(这里只需要提供账号编号, 程序会根据账号编号找到他目前在线的角色).

是否强制查看:
	0	- 如果对方禁止其他玩家查看装备, 那么就不查看
	1	- 就算对方禁止其它玩家查看他的装备, 也强制进行查看

返回值:
	若指定的目标不在线则返回 -1, 若查看成功则返回 1, 若查看失败(比如对方禁止查看)则返回 0

---------------------------------------

*itemexists <物品编号>;
*itemexists "物品名称";
*existitem <物品编号>;
*existitem "物品名称";

确认服务器的 item_db 中是否存在指定物品, 在由玩家输入一些物品编号来执行功能时, 先使用该指令判断一下可以防止直接 getitem 或者 delitem 导致地图服务器终端显示报错信息.

返回值:
	若服务器中不存在此道具则返回0, 若物品存在且可叠加则返回"正数"的物品编号, 若不可堆叠则返回"负数"的物品编号.

---------------------------------------

*setrenttime <装备位置编号>,<增减的时间秒数>{,<角色编号>};
*resume <装备位置编号>,<增减的时间秒数>{,<角色编号>};

增加/减少指定位置装备的租赁时间(如果要减少租赁时间的话, 第二个参数请使用负数).

装备位置编号: 是指 EQI_* 开头的位置常量.

返回值:
	如果指定的装备位置无效或者没有装备则返回 -1, 返回 0 表示此物品不是租赁道具(永不过期), 如果返回大于 0 的数则表示此物品是租赁道具(返回值就是它被您增减时间之后, 剩余时间的秒数)	

---------------------------------------

*battleignore <开关标记>{,<角色编号>};

将指定的角色设置为魔物无视状态(魔物会无视此玩家的存在, 因此不会攻击该玩家, 或许可以叫无敌状态), 避免被魔物攻击.

开关标记:
	0 关闭无视(角色会被魔物看见), 1 打开无视(角色不会被魔物看见, 也不会被攻击)

返回值:
	该指令无论成功失败, 都不会有返回值

---------------------------------------

*getequipexpiretick <装备位置编号>{,<角色编号>};
*isrental <装备位置编号>{,<角色编号>};

获得指定位置装备的租赁到期剩余秒数.

返回值:
	如果指定的装备位置无效或者没有装备则返回 -1, 返回 0 表示此物品不是租赁道具(永不过期), 如果返回大于 0 的数则表示此物品是租赁道具(返回值就是它剩余时间的秒数)	

---------------------------------------

*sc_check <状态编号>{,<gid>};

用于判断指定的状态(Buff)是否存在, 并取得状态参数.

当返回值为1的时候, 可以通过以下变量来读取状态的参数:

@sc_val1		状态的第1个参数(如果是技能对应的状态的话, 往往这个参数都是技能等级)
@sc_val2		状态的第2个参数
@sc_val3		状态的第3个参数
@sc_val4		状态的第4个参数
@sc_tickleft	状态的剩余时间(单位为毫秒)

返回值:
	0 表示玩家身上没有你指定的状态(Buff), 1 表示玩家身上拥有你指定的状态(Buff)

---------------------------------------

*when_pcmove_doevent;

当玩家的角色在下一次移动时, 触发 OnPCMoveFilter 事件.

注意: 只有当 conf/battle/extend.conf 的 pc_move_event_trigger_type 选项为 1 时, 该脚本指令才会有价值.

返回值:
	该指令无论成功失败, 都不会有返回值

---------------------------------------

*processhalt;

在部分支持的事件处理脚本中使用后, 能够在事件脚本结束时, 中断源代码的后续逻辑. 
此功能仅供脚本专家们使用, 没弄明白它的工作逻辑之前, 请慎重使用.

真心话:
	由于事件队列机制的影响, 这个功能远比想象的要鸡肋, 只是为了兼容一下 SeAr, 能不用就尽量别用吧.

该指令特定情况下会失效:
	该指令的使用流程中, 在使用 processhalt 之前不能出现 sleep、sleep2、next、close2、menu、
	select、prompt、input、progressbar 等会导致脚本暂停的指令, 否则它的中断效果将失效.
	
	主要原因是: 如果你执行了这些指令, 那么服务端需要等待客户端或者玩家做出响应, 
	而一旦出现这种情况服务端会立刻将此事件认为“执行告一段落”, 然后就立刻去判断是否需要中断, 
	但是由于你 processhalt 写在了这些会导致脚本暂停的指令后面, 
	所以在还没来得及执行 processhalt 的时候服务端就会认为不需要中断而结束.

失效可能会带来效果错乱:
	此外如果错误的使用了 processhalt 的执行顺序, 也会影响到下一次此事件的触发效果,
	下一次触发此事件时不管是否执行过 processhalt, 都会被认为需要中断.

事件队列机制的影响说明:
	举个例子, 我们可能需要使用 processhalt 在特定的情况下中断 OnPCEquipFilter 事件,
	以达到禁止玩家穿戴装备的目的. 但是只这么做是不完善的,  在特定情况下可能完全失效.
	
	为了避免一个玩家同时执行多个脚本带来的冲突, rAthena 的脚本引擎实现了一个“事件队列”功能,
	此功能能够当玩家在执行某个脚本的时候, 将接下来可能需要玩家执行的脚本预先存放到队列里面,
	等玩家执行完上个脚本再继续触发执行下一个脚本的内容.
	
	这将导致出现一种情况, 如果玩家在和 NPC 对话的情况下去穿戴装备的话, 
	那么此时 OnPCEquipFilter 事件将会被放进队列中而不会立刻执行. 
	您的脚本代码无法对 OnPCEquipFilter 事件进行 processhalt 处理, 
	进而地图服务器会认为玩家穿戴装备这个事情没有被中断, 而允许成功穿戴装备.

支持的事件以及其中断作用说明请见: doc\rAthenaCN_events.txt

---------------------------------------

*script4each "{<脚本>}",<覆盖范围>{,<参数>...};

对指定范围的玩家执行相同的一段脚本

全服玩家			- script4each "{<脚本>}",0;
指定地图			- script4each "{<脚本>}",1,"地图名";
指定区域			- script4each "{<脚本>}",2,"地图名",中心坐标x,中心坐标y,范围;
指定玩家所在的队伍	- script4each "{<脚本>}",3,玩家角色编号;
指定玩家所在的公会	- script4each "{<脚本>}",4,玩家角色编号;
指定区域			- script4each "{<脚本>}",5,"地图名",坐标x0,坐标y0,坐标x1,坐标y1;
指定队伍			- script4each "{<脚本>}",6,队伍编号;
指定公会			- script4each "{<脚本>}",7,公会编号;

注意: 
	如果<脚本>中有使用到大括号的话, 需要在大括号的左侧使用 \ 来进行转义, 例如:
	script4each "{ if (BaseLevel >= 10) \{ getitem 501, 10;\} }",0;

警告:
	目前 script4each 所执行的脚本中, 禁止出现会导致脚本进入暂停状态的指令.
	比如 sleep、sleep2、next、close2、menu、select、prompt、input、progressbar 等, 他们的特点是执行这些指令时, 
	都需要等待客户端/玩家返回一定的信息或做出选择才能继续往下执行.

返回值:
	该指令无论成功失败, 都不会有返回值

---------------------------------------

*gethotkey <快捷键位置编号>{,<要获取的数据类型>};
*get_hotkey <快捷键位置编号>{,<要获取的数据类型>};

获取指定快捷键位置的信息, 快捷键位置编号必须大于 0 小于等于 MAX_HOTKEYS (这是个常量, 脚本中可以直接使用).

要获取的数据类型:
	0	- 获取快捷键的类型 (0 表示该位置的快捷键上放的是一个物品, 1 表示该位置的快捷键上放的是一个技能)
	1	- 获取技能编号或物品的编号
	2	- 获取登记在快捷键上的技能等级

返回值:
	如果参数不合法则返回 -1, 否则返回的是你想要获取的数据内容

---------------------------------------

*sethotkey <快捷键位置编号>,<快捷键的类型>,<物品编号/技能编号>,<技能等级>;
*set_hotkey <快捷键位置编号>,<快捷键的类型>,<物品编号/技能编号>,<技能等级>;

设置玩家快捷键上的内容, 快捷键位置编号必须大于 0 小于等于 MAX_HOTKEYS (这是个常量, 脚本中可以直接使用).

快捷键的类型:
	0	- 这个快捷键位置想放置一个物品 (若使用该值, 则最末尾的"技能等级"参数无意义, 请直接给"技能等级"参数传 0 )
	1	- 这个快捷键位置想放置一个技能

返回值:
	设置成功则返回 1, 设置失败则返回 0

---------------------------------------

*bonus_script_remove "<要移除的脚本代码>"{,<角色编号>};

移除指定的 bonus_script 效果

---------------------------------------

*setpolicyid <行为策略编号>{,<角色编号>};

设置指定玩家的行为策略编号, 配合 conf/policies.conf 中定义的规则来使用.

行为策略编号:
	即在 conf/policies.conf 定义的 policy_id 编号.

返回值:
	设置成功则返回 1, 设置失败则返回 0

---------------------------------------

*getpolicyid {<角色编号>};

获得指定玩家的行为策略编号, 配合 conf/policies.conf 中定义的规则来使用.

返回值:
	设置成功则返回行为策略编号, 设置失败则返回 -1

---------------------------------------

*getpolicyinfo <行为策略信息编号>{,<角色编号>};

获得指定玩家当前的行为策略详情, 配合 conf/policies.conf 中定义的规则来使用.

行为策略信息编号(与 conf/policies.conf 中的字段对应):
	0	- base_exp_rate
	1	- job_exp_rate
	2	- drop_rate
	3	- look_head_top
	4	- bind_group_id

返回值:
	成功则获得你想要查询的信息的值, 失败则返回 -1

---------------------------------------

*setchartitle <称号ID>{,<角色编号>};

设置指定玩家的称号ID, 该指令只在客户端版本号大于等于 20150513 的时候有效.

称号ID:
	这个称号的ID在客户端的 data\luafiles514\lua files\datainfo\titletable.lub 中获取. 例如: 1000

返回值:
	设置成功则返回 1, 设置失败则返回 0

---------------------------------------

*getchartitle {<角色编号>};

获得指定玩家的称号ID, 该指令只在客户端版本号大于等于 20150513 的时候有效.

返回值:
	设置成功则返回目标玩家的称号ID(若为 0 则表示此玩家没有称号), 设置失败则返回 -1

---------------------------------------

*query_multidb "拓展数据库的连接名称","SQL查询语句"{, <数组变量1>{, <数组变量2>{, ...}}};

对拓展数据库执行SQL查询, 用法和 query_sql 类似, 只是多了一个"拓展数据库的连接名称"参数, 用来指定要操作的拓展数据库.

拓展数据库的定义:
	在默认情况下, rAthena 提供的脚本指令只能操作主数据库(query_sql)和日志数据库(query_logsql), 但如果我们需要操作第三个数据库(比如 DiscuzX 论坛数据库) 的时候, rAthena 自带的指令就无能为力了. 为了拓展脚本的能力, rAthenaCN 能够允许你通过 conf/multidb_athena.conf 配置文件来定义拓展数据库, 并使用 query_multidb 对其进行操作.

返回值:
	与 query_sql、query_logsql 类似, 不再敷述

---------------------------------------

*recalculatestat;
*statuscalc;
*status_calc;

该指令的原名 recalculatestat 是 rAthena 的官方自带脚本指令, 在此为了兼容一些脚本, 赋予了 statuscalc 和 status_calc 两个别名给它.

---------------------------------------

*getequipidx <装备位置编号>,{<角色编号>};

用来获取穿戴在指定位置的装备的“背包位置序号”.

注意: “装备位置编号”和 getequipid 一样, 是 EQI_* 开头的常量(而不是 EQP_* 开头的常量).

返回值:
	-1	- 在指定的位置找不到装备
	-2	- 装备位置编号无效
	-3	- 指定的角色编号无效或者目标玩家不在线
	其他大于等于 0 的数值, 则表示成功, 返回值就是所查位置装备的“背包位置序号”.

---------------------------------------

*getoptionitem <item id>,<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<Random Option 字符串数组>{,<account ID>};
*getoptionitem "<item name>",<amount>,<identify>,<refine>,<attribute>,<card1>,<card2>,<card3>,<card4>,<Random Option 字符串数组>{,<account ID>};

[指令弃用声明]
该指令于 '2017-05-13' 开始被声明弃用, 在未来版本中可能随时会被移除.
您应该使用 rAthena 官方新提供的 getitem3 指令来替代它, 详细用法请见: doc\script_commands.txt

根据你提供的一个“Random Option 字符串数组”, 创造出带有指定 Random Option 的道具到玩家的背包中(注意, 如果创造的道具不是“装备”类型的道具, 那么<Random Option 字符串数组>字段将被无视).

单个数组元素的格式:
	<id>|<value>|<param>
	
<Random Option 字符串数组> 的初始化示例:
	setarray .@opt$[0], 
		"RDMOPT_VAR_MAXHPAMOUNT|10000|0",
		"RDMOPT_VAR_MAXSPAMOUNT|10000|0";
	
注意: <Random Option 字符串数组> 的元素长度最大不能超过 5 个, 超过的部分将被无视.

返回值:
	该指令无论成功失败, 都不会有返回值. 有错误会直接输出到地图服务器的终端窗口中.

例如, 要创造一个拥有“最大HP增加20000”拓展属性的短剑, 那么脚本代码如下:

	setarray .@opt$[0], 
		"RDMOPT_VAR_MAXHPAMOUNT|20000|0";
		
	getoptionitem 1201,1,1,0,0,0,0,0,0,.@opt$;

---------------------------------------

*readoptarray(<Random Option 字符串数组>,<第几个Option>,<要读取的数据类型>);

[指令弃用声明]
该指令于 '2017-05-13' 开始被声明弃用, 在未来版本中可能随时会被移除.

快速从 Random Option 字符串数组中读取指定的内容.

要读取的数据类型:
	ROA_ID - 随机属性的ID, 要和 db/re/item_randomopt_db.txt 中的对应
	ROA_VALUE - 随机属性的值
	ROA_PARAM - 随机属性的参数(这个参数的作用取决于item_randomopt_db.txt中如何使用ROA_PARAM, 目前看来所有官方的随机属性都没有用到这个参数)

现在举例说明如何快速的从一个<Random Option 字符串数组>中读取想要的内容:

	setarray .@opt$[0], 
		"RDMOPT_VAR_MAXHPAMOUNT|10000|0",
		"RDMOPT_VAR_MAXSPAMOUNT|5000|0";
	
	// 读取 .@opt$ 中索引为 1 (第二个元素)的 ROA_VALUE 的值
	.@result = readoptarray(.@opt$,1,ROA_VALUE);		// .@result = 5000
	
	// 读取 .@opt$ 中索引为 0 (第一个元素)的 ROA_ID 的值
	// 这里不会返回常量字符串 RDMOPT_VAR_MAXHPAMOUNT, 
	// 而是根据 const.txt 中的定义返回 RDMOPT_VAR_MAXHPAMOUNT 对应的数值 1
	.@result = readoptarray(.@opt$,0,ROA_ID);		// .@result = 1

返回值:
	正常的话能返回所需要的内容, 出错则返回 -1

---------------------------------------

*writeoptarray(<Random Option 数组>,<第几个Option>,<要修改的数据类型>,<新的值>);

[指令弃用声明]
该指令于 '2017-05-13' 开始被声明弃用, 在未来版本中可能随时会被移除.

快速从 Random Option 字符串数组中修改指定的内容.

要修改的数据类型:
	ROA_ID - 随机属性的ID, 要和 db/re/item_randomopt_db.txt 中的对应
	ROA_VALUE - 随机属性的值
	ROA_PARAM - 随机属性的参数(这个参数的作用取决于item_randomopt_db.txt中如何使用ROA_PARAM, 目前看来所有官方的随机属性都没有用到这个参数)

现在举例说明如何快速的从一个<Random Option 字符串数组>中修改想要的内容:

	setarray .@opt$[0], 
		"RDMOPT_VAR_MAXHPAMOUNT|10000|0",
		"RDMOPT_VAR_MAXSPAMOUNT|5000|0";
	
	// 修改 .@opt$ 中索引为 1 (第二个元素)的 ROA_VALUE 的值为 5121
	.@result = writeoptarray(.@opt$,1,ROA_VALUE,5121);
	
	// 修改 .@opt$ 中索引为 0 (第一个元素)的 ROA_ID 的值为 RDMOPT_VAR_STRAMOUNT
	.@result = writeoptarray(.@opt$,0,ROA_ID,RDMOPT_VAR_STRAMOUNT);

返回值:
	操作成功则返回 1, 失败则返回 0

---------------------------------------

*getoptionarraybyidx <背包位置序号>,<保存到的目标 Random Option 数组名称>;

[指令弃用声明]
该指令于 '2017-05-13' 开始被声明弃用, 在未来版本中可能随时会被移除.

给定背包位置序号, 获取一个用来表示此物品的 Random Option 字符串数组.

例如:
	getoptionarraybyidx 2,.@save_opt$;	// 记住数组是字符串类型的, 结尾要有 $ 符号

返回值:
	操作成功则返回 1, 失败则返回 0

---------------------------------------

*getoptionarraybypos <装备位置编号>,<保存到的目标 Random Option 数组名称>;

[指令弃用声明]
该指令于 '2017-05-13' 开始被声明弃用, 在未来版本中可能随时会被移除.

给定装备位置编号, 获取一个用来表示此物品的 Random Option 字符串数组.

装备位置编号: 是指 EQI_* 开头的位置常量.

例如:
	getoptionarraybypos EQI_HAND_R,.@save_opt$;	// 记住数组是字符串类型的, 结尾要有 $ 符号

返回值:
	操作成功则返回 1, 失败则返回 0

---------------------------------------

*resetoptionbyidx <背包位置序号>;

给定背包位置序号, 清空指定物品的 Random Option 内容.

此选项会在 picklog 日志表中留下道具的变化痕迹.

返回值:
	操作成功则返回 1, 失败则返回 0

---------------------------------------

*resetoptionbypos <装备位置编号>;

给定装备位置编号, 清空指定物品的 Random Option 内容.

装备位置编号: 是指 EQI_* 开头的位置常量.

此选项会在 picklog 日志表中留下道具的变化痕迹.

返回值:
	操作成功则返回 1, 失败则返回 0

---------------------------------------

*getidxrandomoption(<背包序号>,<Random Option序号>,<要修改的数据类型>{,<角色编号>});

获取背包序号指定道具的 Random Option 属性的值.

要修改的数据类型:
	ROA_ID - 随机属性的ID, 要和 db/re/item_randomopt_db.txt 中的对应
	ROA_VALUE - 随机属性的值
	ROA_PARAM - 随机属性的参数(这个参数的作用取决于item_randomopt_db.txt中如何使用ROA_PARAM, 目前看来所有官方的随机属性都没有用到这个参数)

返回值:
	操作成功则返回查询的值, 失败则返回 -1, 如果因为请求的<类型>无效而失败则返回 0

---------------------------------------

*setidxrandomoption(<背包序号>,<Random Option序号>,<id>,<value>,<param>{,<角色编号>});

设置背包序号指定道具的 Random Option 属性.

如果被设定的道具未被穿戴, 那么会先告诉客户端该道具被删除, 
然后完成对道具的属性修改后, 再告诉客户端你获得了一个新道具, 此时聊天栏会有个提示.

如果被设定的道具已被穿戴, 那么会先将装备脱下, 然后告诉客户端该道具被删除, 
接着完成对道具的属性修改后, 再告诉客户端你获得了一个新道具, 并自动将装备穿戴上.

该道具的背包序号不会因为该指令的操作而被修改.

此选项会在 picklog 日志表中留下道具的变化痕迹.

返回值:
	操作成功则返回 1, 失败则返回 0

---------------------------------------

*getiteminfo(<物品编号>,<类型>)

在原来类型的基础上, rAthenaCN 新增了以下类型:

17 - 是否可精炼, 1表示可以精炼, 0表示不能精炼
18 - 交易限制掩码, 将返回该物品在 item_trade 数据库中第二列定义的值
19 - 不会因玩家主动使用而被消耗, 1表示是, 0表示否
20 - 不会被技能当做消耗品而消耗, 1表示是, 0表示否
21 - 是否为宠物捕捉道具, 0表示否, 若是则返回能捕获的魔物编号
22 - 是否在其使用脚本中调用了 callfunc 指令, 1表示是, 0表示否 (复兴前版本返回 -1)

---------------------------------------

*copynpc("<复制出来的新NPC所在地图名称>,<X坐标>,<Y坐标>,<朝向编号>","duplicate(<来源NPC名称>)","<复制出来的新NPC名称>","<角色编号>");

将一个指定的NPC复制到一个新的位置.
主要的参数是4个字符串, 这四个字符串与使用 duplicate 进行静态复制时候的四个用 %TAB% 分隔的内容是一样的.

假设有以下NPC, 我们想把它复制一个新的出来:

	prontera,146,99,2    script    PVP管理员::PVPCOPYTEST    917,{
		mes "[PVP管理员]";
		mes "场地正在修理, 请稍后再来...";
		close;
	}

通常的做法是在脚本中, 使用 duplicate 指令进行静态复制, 如:

	prontera,156,99,2	duplicate(PVPCOPYTEST)	PVP管理员#1	917

现在你可以使用 copynpc 脚本指令, 将上面这一行静态复制代码按 %TAB% 分割为4个字段, 然后以字符串形式传递给 copynpc 脚本指令, 如:

	copynpc "prontera,156,99,2","duplicate(PVPCOPYTEST)","PVP管理员#1","917";

同时此函数支持返回复制出来的新NPC的GID, 方便你使用 unit 系列指令对其进行操作, 如:

	.@gid = copynpc("prontera,156,99,2","duplicate(PVPCOPYTEST)","PVP管理员#1","917");
	unittalk .@gid, "My GID is : " + .@gid;
	
如果想要复制一个副本中的NPC, 那么需要在用到地图名称的地方使用 instance_mapname 进行转换, 原始NPC的名称也需要用 instance_npcname 进行转换, 如:

	.@w1 = instance_mapname("1@tower") + ",156,99,2";
	.@w2 = "duplicate(" + instance_npcname("PVPCOPYTEST") + ")";
	.@w3 = "PVP管理员#1";
	.@w4 = "917";
	
	copynpc .@w1, .@w2, .@w3, .@w4;

返回值:
	复制成功, 则返回复制出来的新NPC的GID, 失败则返回 0

---------------------------------------

*getareagid("<地图名>",<查询的单位类型>,<x0>,<y0>,<x1>,<y1>,<返回数组>);
*getareagid("<地图名>",<查询的单位类型>,<中心坐标x>,<中心坐标y>,<半径>,<返回数组>);
*getareagid("<地图名>",<查询的单位类型>,<返回数组>);

当地图名为 this 时, 表示为执行脚本的玩家所在的地图, 此时脚本必须关联玩家.

查询的单位类型:
	BL_PC		- 玩家单位
	BL_MOB		- 魔物单位
	BL_PET		- 宠物单位
	BL_HOM		- 人工生命体单位
	BL_MER		- 佣兵单位
	BL_ITEM		- 物品单位 (拿到了也暂时用不上)
	BL_SKILL	- 技能单位 (拿到了也暂时用不上)
	BL_NPC		- NPC单位
	BL_CHAT		- 聊天室单位 (拿到了也暂时用不上)
	BL_ELEM		- 元素精灵单位 (拿到了也暂时用不上)

返回数组:
	填写一个你希望查到的 GID 存储的数字类型数组的变量名, 比如 .@gids
	
	注意: 这里给定的变量名, 务必要考虑执行该指令的时候, 脚本是否关联了玩家, 
	如果没有关联的话需要使用和玩家无关的变量类型, 比如 $@ 开头的变量
	
举个例子:
prontera,150,90,4	script	getareagid_test	123,{
	.@result = getareagid("this", BL_NPC, .@gids);
	if (.@result < 0) {
		dispbottom "执行 getareagid 时发生了错误, 返回值为: " + .@result;
	}
	
	for (.@i = 0; .@i < .@result; .@i++) {
		dispbottom ".@gids[" + .@i + "] = " + .@gids[.@i] + " NPC名称为: " + getunitname(.@gids[.@i]);
	}
}

返回值:
	返回大于 0 的数值: 表示找到了单位, 返回的数值为找到的单位个数
	返回 -1 : 指定地图为 this 但是没有关联玩家
	返回 -2 : 给定的地图名字是无效的, 找不到地图
	返回 -3 : 传递的参数个数不对, 必须是3个、6个或者7个参数
	返回 -4 : 给定的"返回数组"类型不对, 不能是一个字符串或数值常量, 也不能是字符串数组
	返回 -5 : 给定的"返回数组"是一个需要依赖玩家的变量类型, 但是没有关联玩家 (比如 . 或 .@ 开头的数字类型数组)

致谢:
	感谢 “╰づ记忆•斑驳〤” 提供实现代码

---------------------------------------

*sendmail(<收件人角色编号>,"<发送者名称>","<标题>","<内容>"{,<附件中的金币>{,<附件一的物品编号>,<附件一的物品数量>{,<附件二的物品编号>,<附件二的物品数量>{,<附件三的物品编号>,<附件三的物品数量>{,<附件四的物品编号>,<附件四的物品数量>{,<附件五的物品编号>,<附件五的物品数量>}}}}}});
*sendmail2(<收件人角色编号>,"<发送者名称>","<标题>","<内容>"{,<附件中的金币>{,<附件一的物品编号>,<附件一的物品数量>,<附件一是否已鉴定>,<附件一的精炼值>,<附件一的属性>,<附件一的第一张卡片>,<附件一的第二张卡片>,<附件一的第三张卡片>,<附件一的第四张卡片>{,<附件二的物品编号>,<附件二的物品数量>,<附件二是否已鉴定>,<附件二的精炼值>,<附件二的属性>,<附件二的第一张卡片>,<附件二的第二张卡片>,<附件二的第三张卡片>,<附件二的第四张卡片>{,<附件三的物品编号>,<附件三的物品数量>,<附件三是否已鉴定>,<附件三的精炼值>,<附件三的属性>,<附件三的第一张卡片>,<附件三的第二张卡片>,<附件三的第三张卡片>,<附件三的第四张卡片>{,<附件四的物品编号>,<附件四的物品数量>,<附件四是否已鉴定>,<附件四的精炼值>,<附件四的属性>,<附件四的第一张卡片>,<附件四的第二张卡片>,<附件四的第三张卡片>,<附件四的第四张卡片>{,<附件五的物品编号>,<附件五的物品数量>,<附件五是否已鉴定>,<附件五的精炼值>,<附件五的属性>,<附件五的第一张卡片>,<附件五的第二张卡片>,<附件五的第三张卡片>,<附件五的第四张卡片>}}}}}});
*sendmail3(<收件人角色编号>,"<发送者名称>","<标题>","<内容>"{,<附件中的金币>{,<附件一的物品编号>,<附件一的物品数量>,<附件一是否已鉴定>,<附件一的精炼值>,<附件一的属性>,<附件一的第一张卡片>,<附件一的第二张卡片>,<附件一的第三张卡片>,<附件一的第四张卡片>,<附件一的RandomIDArray>,<附件一的RandomValueArray>,<附件一的RandomParamArray>{,<附件二的物品编号>,<附件二的物品数量>,<附件二是否已鉴定>,<附件二的精炼值>,<附件二的属性>,<附件二的第一张卡片>,<附件二的第二张卡片>,<附件二的第三张卡片>,<附件二的第四张卡片>,<附件二的RandomIDArray>,<附件二的RandomValueArray>,<附件二的RandomParamArray>{,<附件三的物品编号>,<附件三的物品数量>,<附件三是否已鉴定>,<附件三的精炼值>,<附件三的属性>,<附件三的第一张卡片>,<附件三的第二张卡片>,<附件三的第三张卡片>,<附件三的第四张卡片>,<附件三的RandomIDArray>,<附件三的RandomValueArray>,<附件三的RandomParamArray>{,<附件四的物品编号>,<附件四的物品数量>,<附件四是否已鉴定>,<附件四的精炼值>,<附件四的属性>,<附件四的第一张卡片>,<附件四的第二张卡片>,<附件四的第三张卡片>,<附件四的第四张卡片>,<附件四的RandomIDArray>,<附件四的RandomValueArray>,<附件四的RandomParamArray>{,<附件五的物品编号>,<附件五的物品数量>,<附件五是否已鉴定>,<附件五的精炼值>,<附件五的属性>,<附件五的第一张卡片>,<附件五的第二张卡片>,<附件五的第三张卡片>,<附件五的第四张卡片>,<附件五的RandomIDArray>,<附件五的RandomValueArray>,<附件五的RandomParamArray>}}}}}});

使用该指令, 可以给指定的玩家发送一封邮件. 三个不同版本的指令其实只是支持的参数有所不同.

版本区别:
	sendmail 	可以发送简单的附件(无任何卡片或者精练值的道具, 药水等)
	sendmail2	可以发送比较复杂的附件(可设定卡片、精炼值等)
	sendmail3	除了卡片和精炼值之外, 还可以支持 Random Options (随机属性)

演示脚本:
	关于这一系列的指令使用方法, 可以参考 npc\racn\racn_sendmail.txt 演示脚本

注意事项:
	这一系列的指令不会去尝试判断收件人角色编号是否合法, 需要自己做判断.
	若客户端不支持RODEX的话, 那么附件只有第一个会有效.

返回值:
	该指令无论成功失败, 都不会有返回值

---------------------------------------

*showvend("<NPC名称>",<是否显示>{,"<招牌名称>"});

使指定<NPC名称>头上显示露天商店的招牌, 点击招牌可触发NPC

是否显示:
	0 - 隐藏招牌
	1 - 显示招牌

用法:
prontera,150,150,4	shop	Vend_Title_Test	48,501:-1

-	script	NPC_Vend	48,{
end;
OnInit:
	showvend("Vend_Title_Test", 1, "有招牌的商店");
end;
}

返回值:
	操作成功则返回 1, 失败则返回 0

---------------------------------------
